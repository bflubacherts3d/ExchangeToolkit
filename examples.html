<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Exchange Toolkit: Examples</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ExchangeToolkit.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Exchange Toolkit
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Examples </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#example_attrib">Attaching attributes to B-Rep faces and edges</a></li>
<li class="level1"><a href="#example_bom">Constructing a Bill of Materials</a></li>
<li class="level1"><a href="#example_compare_brep_tess">Comparing tessellation to B-Rep</a></li>
<li class="level1"><a href="#example_pmi_linked_items">How to access Markup/PMI Linked Items</a></li>
<li class="level1"><a href="#example_wire_body_curve_types">Print curve types that make up a wire body</a></li>
<li class="level1"><a href="#example_obj">Write an OBJ file</a></li>
<li class="level1"><a href="#example_print_structure">Print the product structure</a></li>
</ul>
</div>
<div class="textblock"><p>All of the example code snippets found below are extracted from the <code>examples</code> folder. </p><dl class="section attention"><dt>Attention</dt><dd>The sample code provided here and in the <code>examples</code> folder is provided as-is. You are free to use it and adapt it as needed.</dd></dl>
<h1><a class="anchor" id="example_attrib"></a>
Attaching attributes to B-Rep faces and edges</h1>
<p>This snippet was extracted from <code>examples/attrib/main.cpp</code>. </p><div class="fragment"><div class="line">    <span class="comment">// Get all unique parts from the model file</span></div><div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> parts = <a class="code" href="group__traversal.html#ga9978df59c99dd85d89eb5cbd9d488ace">ts3d::getUniqueLeafEntities</a>( loader.m_psModelFile, kA3DTypeAsmPartDefinition );</div><div class="line">    <span class="keywordflow">for</span>( <span class="keyword">auto</span> <span class="keyword">const</span> part : parts ) {</div><div class="line">        <span class="comment">// Attach an arbitrary attribute to the part</span></div><div class="line">        A3DRootBaseAttributeAdd( part, const_cast&lt;char*&gt;(<span class="stringliteral">&quot;part&quot;</span>), const_cast&lt;char*&gt;(<span class="stringliteral">&quot;foobar&quot;</span>) );</div><div class="line">        <span class="comment">// Get the B-Rep model(s) from the part definition</span></div><div class="line">        <span class="keyword">auto</span> <span class="keyword">const</span> brep_models = <a class="code" href="group__traversal.html#gaf65a30c9e905e2987bf29fd96296cc6c">ts3d::getLeafInstances</a>( part, kA3DTypeRiBrepModel );</div><div class="line">        <span class="keywordflow">for</span>( <span class="keyword">auto</span> <span class="keyword">const</span> brep_model : brep_models ) {</div><div class="line">            <span class="comment">// Obtain the scale associated with this model</span></div><div class="line">            <a class="code" href="structts3d_1_1_a3_d_ri_brep_model_wrapper.html">ts3d::A3DRiBrepModelWrapper</a> d( brep_model.back() );</div><div class="line">            <a class="code" href="structts3d_1_1_a3_d_topo_body_wrapper.html">ts3d::A3DTopoBodyWrapper</a> topo_body( d-&gt;m_pBrepData );</div><div class="line">            <a class="code" href="structts3d_1_1_a3_d_topo_context_wrapper.html">ts3d::A3DTopoContextWrapper</a> topo_context( topo_body-&gt;m_pContext );</div><div class="line">            A3DVector3dData scale;</div><div class="line">            A3D_INITIALIZE_DATA( A3DVector3dData, scale );</div><div class="line">            scale.m_dX = scale.m_dY = scale.m_dZ = ( topo_context-&gt;m_bHaveScale ? topo_context-&gt;m_dScale : 1. );</div><div class="line"></div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> faces = <a class="code" href="group__traversal.html#ga9978df59c99dd85d89eb5cbd9d488ace">ts3d::getUniqueLeafEntities</a>( brep_model.back(), kA3DTypeTopoFace );</div><div class="line">            <span class="keywordflow">for</span>( <span class="keyword">auto</span> <span class="keyword">const</span> face : faces ) {</div><div class="line">                <span class="comment">// add face attributes</span></div><div class="line">                ts3d::attachFaceAttributes( face, scale );</div><div class="line">            }</div><div class="line">            </div><div class="line">            <a class="code" href="group__traversal.html#ga3ed69e7c86088be4aad8deaa8fa94cef">ts3d::InstancePathMap</a> edge_instance_path_map;</div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> edges = <a class="code" href="group__traversal.html#ga9978df59c99dd85d89eb5cbd9d488ace">ts3d::getUniqueLeafEntities</a>( brep_model.back(), kA3DTypeTopoEdge, edge_instance_path_map );</div><div class="line">            <span class="keywordflow">for</span>( <span class="keyword">auto</span> <span class="keyword">const</span> edge : edges ) {</div><div class="line">                <span class="keyword">auto</span> <span class="keyword">const</span> &amp;edge_instances = edge_instance_path_map[edge];</div><div class="line">                <a class="code" href="group__access.html#gae64faaef9322c388f862a125363d4ca0">ts3d::EntitySet</a> owning_faces;</div><div class="line">                <span class="keywordflow">for</span>( <span class="keyword">auto</span> <span class="keyword">const</span> &amp;edge_instance : edge_instances ) {</div><div class="line">                    <span class="comment">// get the face referencing this edge instance</span></div><div class="line">                    <span class="keyword">auto</span> <span class="keyword">const</span> face_it = std::find_if( std::begin( edge_instance ), std::end( edge_instance ), [](A3DEntity *ntt ) {</div><div class="line">                        <span class="keywordflow">return</span> <a class="code" href="group__access.html#gaef7e91c5c7c745e2e3953becbd2324fd">ts3d::getEntityType</a>( ntt ) == kA3DTypeTopoFace;</div><div class="line">                    });</div><div class="line">                    <span class="keywordflow">if</span>( std::end( edge_instance ) != face_it ) {</div><div class="line">                        owning_faces.insert( *face_it );</div><div class="line">                    }</div><div class="line">                }</div><div class="line">                ts3d::attachEdgeAttributes( edge, owning_faces, scale );</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><h1><a class="anchor" id="example_bom"></a>
Constructing a Bill of Materials</h1>
<p>This snippet was extracted from <code>examples/bom/main.cpp</code>. </p><div class="fragment"><div class="line">    </div><div class="line">    <span class="comment">// An instance path map will be used to count the number of part occurrences</span></div><div class="line">    <a class="code" href="group__traversal.html#ga3ed69e7c86088be4aad8deaa8fa94cef">ts3d::InstancePathMap</a> instance_paths;</div><div class="line"></div><div class="line">    <span class="comment">// Obtain a set of unique part definition children</span></div><div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> part_definitions = <a class="code" href="group__traversal.html#ga9978df59c99dd85d89eb5cbd9d488ace">ts3d::getUniqueLeafEntities</a>( loader.m_psModelFile, kA3DTypeAsmPartDefinition, instance_paths );</div><div class="line"></div><div class="line">    <span class="comment">// Iterator over each unique part</span></div><div class="line">    <span class="keywordflow">for</span>( <span class="keyword">auto</span> part_definition : part_definitions ) {</div><div class="line">        <span class="comment">// Get the part&#39;s name or owner&#39;s name if empty</span></div><div class="line">        <a class="code" href="classts3d_1_1_instance.html">ts3d::Instance</a> <span class="keyword">const</span> part_instance( { part_definition } );</div><div class="line">        <span class="keyword">auto</span> <span class="keyword">const</span> part_name = part_instance.<a class="code" href="classts3d_1_1_instance.html#ad510254ee846664c4e9d39af70eef430">getName</a>().empty() ? <span class="stringliteral">&quot;&lt;unknown&gt;&quot;</span> : part_instance.getName();</div><div class="line"></div><div class="line">        <span class="comment">// Print the part name and number of occurrences</span></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;\&quot;&quot;</span> &lt;&lt; part_name &lt;&lt; <span class="stringliteral">&quot;\&quot;: &quot;</span></div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; instance_paths[part_definition].size() </div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot; instance&quot;</span> </div><div class="line">                  &lt;&lt; (1 != instance_paths[part_definition].size() ? <span class="stringliteral">&quot;s)&quot;</span> : <span class="stringliteral">&quot;)&quot;</span>) </div><div class="line">                  &lt;&lt; std::endl;</div><div class="line">    }</div></div><!-- fragment --><h1><a class="anchor" id="example_compare_brep_tess"></a>
Comparing tessellation to B-Rep</h1>
<p>This snippet was extracted from <code>examples/compare_brep_tess/main.cpp</code>. </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> ri_instances = <a class="code" href="group__traversal.html#gaf65a30c9e905e2987bf29fd96296cc6c">ts3d::getLeafInstances</a>( loader.m_psModelFile, kA3DTypeRiBrepModel );</div><div class="line">    <span class="keywordflow">for</span>( <span class="keyword">auto</span> ri_instance : ri_instances ) {</div><div class="line">        </div><div class="line">        <span class="keywordflow">if</span>( SHOULD_FORCE_RETESSELLATION ) {</div><div class="line">            A3DRWParamsTessellationData tess_params;</div><div class="line">            A3D_INITIALIZE_DATA( A3DRWParamsTessellationData, tess_params );</div><div class="line">            tess_params.m_eTessellationLevelOfDetail = kA3DTessLODMedium;</div><div class="line">            tess_params.m_bAccurateTessellation = <span class="keyword">false</span>;</div><div class="line">            CheckResult( A3DRiRepresentationItemComputeTessellation( ri_instance.back(), &amp;tess_params ) );</div><div class="line">        }</div><div class="line">        </div><div class="line">        <a class="code" href="structts3d_1_1_a3_d_ri_brep_model_wrapper.html">ts3d::A3DRiBrepModelWrapper</a> brep_model_d( ri_instance.back() );</div><div class="line">        <a class="code" href="structts3d_1_1_a3_d_topo_body_wrapper.html">ts3d::A3DTopoBodyWrapper</a> topo_body_d( brep_model_d-&gt;m_pBrepData );</div><div class="line">        <a class="code" href="structts3d_1_1_a3_d_topo_context_wrapper.html">ts3d::A3DTopoContextWrapper</a> context_d( topo_body_d-&gt;m_pContext );</div><div class="line">        <span class="keyword">auto</span> <span class="keyword">const</span> brep_scale = context_d-&gt;m_bHaveScale ? context_d-&gt;m_dScale : 1.;</div><div class="line">                </div><div class="line">        <a class="code" href="classts3d_1_1_representation_item_instance.html">ts3d::RepresentationItemInstance</a> <span class="keyword">const</span> ri( ri_instance );</div><div class="line">        <span class="keyword">auto</span> <span class="keyword">const</span> tess3d = std::dynamic_pointer_cast&lt;<a class="code" href="classts3d_1_1_tess3_d_instance.html">ts3d::Tess3DInstance</a>&gt;( ri.getTessellation() );</div><div class="line">        <span class="keywordflow">if</span>( <span class="keyword">nullptr</span> == tess3d ) {</div><div class="line">            <span class="keywordflow">continue</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// ensure the number of tess faces is equal to the number of b-rep faces</span></div><div class="line">        <span class="keyword">auto</span> <span class="keyword">const</span> n_tess_faces = tess3d-&gt;<a class="code" href="classts3d_1_1_tess3_d_instance.html#a333c2f9d1528023f66f44036ae026f7d">faceSize</a>();</div><div class="line">        <span class="keyword">auto</span> <span class="keyword">const</span> brep_faces = <a class="code" href="group__traversal.html#gaf65a30c9e905e2987bf29fd96296cc6c">ts3d::getLeafInstances</a>( ri_instance.back(), kA3DTypeTopoFace );</div><div class="line">        <span class="keywordflow">if</span>( n_tess_faces != brep_faces.size() ) {</div><div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot;FAILURE: n_tess_faces (&quot;</span> &lt;&lt; n_tess_faces &lt;&lt; <span class="stringliteral">&quot;) != brep_faces.size() (&quot;</span> &lt;&lt; brep_faces.size() &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div><div class="line">            failure_encountered = <span class="keyword">true</span>;</div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="comment">// for each face, examine the loops</span></div><div class="line">        <span class="keyword">auto</span> <span class="keyword">const</span> max_face_idx = std::min( static_cast&lt;std::size_t&gt;( n_tess_faces ), brep_faces.size() );</div><div class="line">        <span class="keywordflow">for</span>( <span class="keyword">auto</span> face_idx = 0u; face_idx &lt; max_face_idx; ++face_idx ) {</div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> tess_face = tess3d-&gt;getIndexMeshForFace( face_idx );</div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> brep_face = brep_faces[face_idx].back();</div><div class="line">            <a class="code" href="structts3d_1_1_a3_d_topo_face_wrapper.html">ts3d::A3DTopoFaceWrapper</a> face_d( brep_face );</div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> surface = face_d-&gt;m_pSurface;</div><div class="line">        </div><div class="line">            <span class="comment">// ensure the number of tess loops is equal to the number of b-rep loops</span></div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> tess_loops = tess_face.loops();</div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> n_tess_loops = tess_loops.size();</div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> brep_loops = <a class="code" href="group__traversal.html#gaf65a30c9e905e2987bf29fd96296cc6c">ts3d::getLeafInstances</a>( brep_faces[face_idx].back(), kA3DTypeTopoLoop );</div><div class="line">            <span class="keywordflow">if</span>( n_tess_loops != brep_loops.size() ) {</div><div class="line">                std::cerr &lt;&lt; <span class="stringliteral">&quot;FAILURE: n_tess_loops (&quot;</span> &lt;&lt; n_tess_loops &lt;&lt; <span class="stringliteral">&quot;) != brep_loops.size() (&quot;</span> &lt;&lt; brep_loops.size() &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div><div class="line">                failure_encountered = <span class="keyword">true</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// for each loop, examine the edges</span></div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> max_loop_idx = std::min( n_tess_loops, brep_loops.size() );</div><div class="line">            <span class="keywordflow">for</span>( <span class="keyword">auto</span> loop_idx = 0u; loop_idx &lt; max_loop_idx; ++loop_idx ) {</div><div class="line">                <span class="keyword">auto</span> <span class="keyword">const</span> &amp;tess_loop = tess_loops[loop_idx];</div><div class="line">                </div><div class="line">                <span class="comment">// ensure the number of tess edges is equal to the number of b-rep coedges</span></div><div class="line">                <span class="keyword">auto</span> <span class="keyword">const</span> n_tess_edges = tess_loop._edges.size();</div><div class="line">                <span class="keyword">auto</span> <span class="keyword">const</span> brep_coedges = <a class="code" href="group__traversal.html#gaf65a30c9e905e2987bf29fd96296cc6c">ts3d::getLeafInstances</a>( brep_loops[loop_idx].back(), kA3DTypeTopoCoEdge );</div><div class="line">                <span class="keywordflow">if</span>( n_tess_edges != brep_coedges.size() ) {</div><div class="line">                    std::cerr &lt;&lt; <span class="stringliteral">&quot;FAILURE: n_tess_edges ( &quot;</span> &lt;&lt; n_tess_edges &lt;&lt; <span class="stringliteral">&quot;) != brep_coedges.size() (&quot;</span> &lt;&lt; brep_coedges.size() &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div><div class="line">                    failure_encountered = <span class="keyword">true</span>;</div><div class="line">                }</div><div class="line">                </div><div class="line">                <span class="keyword">auto</span> <span class="keyword">const</span> max_edge_idx = std::min(n_tess_edges, brep_coedges.size());</div><div class="line">                <span class="keywordflow">for</span>( <span class="keyword">auto</span> edge_idx = 0u; edge_idx &lt; max_edge_idx; ++edge_idx ) {</div><div class="line">                    <span class="keyword">auto</span> <span class="keyword">const</span> &amp;tess_edge = tess_loop._edges[edge_idx];</div><div class="line">                    <span class="keyword">auto</span> <span class="keyword">const</span> brep_coedge = brep_coedges[edge_idx];</div><div class="line"></div><div class="line">                    <a class="code" href="structts3d_1_1_a3_d_topo_co_edge_wrapper.html">ts3d::A3DTopoCoEdgeWrapper</a> coedge_d( brep_coedge.back() );</div><div class="line">                    <a class="code" href="structts3d_1_1_a3_d_topo_edge_wrapper.html">ts3d::A3DTopoEdgeWrapper</a> edge_d( coedge_d-&gt;m_pEdge );</div><div class="line">                    A3DCrvBase <span class="keyword">const</span> *curve = <span class="keyword">nullptr</span>;</div><div class="line">                    CheckResult( A3DTopoEdgeGetOrCompute3DCurve( brep_model_d-&gt;m_pBrepData, coedge_d-&gt;m_pEdge, &amp;curve ) );</div><div class="line"></div><div class="line">                    A3DIntervalData interval;</div><div class="line">                    A3D_INITIALIZE_DATA( A3DIntervalData, interval );</div><div class="line">                    <span class="keywordflow">if</span>( edge_d-&gt;m_bHasTrimDomain ) {</div><div class="line">                        interval = edge_d-&gt;m_sInterval;</div><div class="line">                    } <span class="keywordflow">else</span> {</div><div class="line">                        CheckResult( A3DCrvGetInterval( curve, &amp;interval ) );</div><div class="line">                    }</div><div class="line">                    </div><div class="line">                    <span class="keywordflow">for</span>( <span class="keyword">auto</span> <span class="keyword">const</span> vertex_index : tess_edge._vertices ) {</div><div class="line">                        A3DVector3dData pt;</div><div class="line">                        A3D_INITIALIZE_DATA( A3DVector3dData, pt );</div><div class="line">                        pt.m_dX = tess3d-&gt;coords()[vertex_index] / brep_scale;</div><div class="line">                        pt.m_dY = tess3d-&gt;coords()[vertex_index + 1] / brep_scale;</div><div class="line">                        pt.m_dZ = tess3d-&gt;coords()[vertex_index + 2] / brep_scale;</div><div class="line">                    </div><div class="line">                        <span class="comment">// project the point to the curve</span></div><div class="line">                        A3DUns32 n_solutions = 0u;</div><div class="line">                        A3DDouble *parameters = <span class="keyword">nullptr</span>, *distances = <span class="keyword">nullptr</span>;</div><div class="line">                        CheckResult( A3DCrvProjectPoint( curve, &amp;pt, &amp;n_solutions, &amp;parameters, &amp;distances ) );</div><div class="line"></div><div class="line">                        <span class="keyword">auto</span> min_curve_distance = std::numeric_limits&lt;double&gt;::max();</div><div class="line">                        <span class="keywordflow">for</span>( <span class="keyword">auto</span> n_solution = 0u; n_solution &lt; n_solutions; ++n_solution ) {</div><div class="line">                            <span class="keywordflow">if</span>( distances[n_solution] &lt; min_curve_distance ) {</div><div class="line">                                min_curve_distance = distances[n_solution];</div><div class="line">                            }</div><div class="line">                        }</div><div class="line">                        CheckResult( A3DCrvProjectPoint( <span class="keyword">nullptr</span>, &amp;pt, &amp;n_solutions, &amp;parameters, &amp;distances ) );</div><div class="line">                        </div><div class="line">                        <span class="comment">// check resulting error against tolerance</span></div><div class="line">                        <span class="keyword">auto</span> <span class="keyword">const</span> curve_error = min_curve_distance;<span class="comment">// * brep_scale;</span></div><div class="line">                        <span class="keywordflow">if</span>( curve_error &gt; TOLERANCE ) {</div><div class="line">                            std::cerr &lt;&lt; <span class="stringliteral">&quot;FAILURE: [Distance to curve] &quot;</span> &lt;&lt; curve_error &lt;&lt; <span class="stringliteral">&quot; &gt; &quot;</span> &lt;&lt; TOLERANCE &lt;&lt; std::endl;</div><div class="line">                            failure_encountered = <span class="keyword">true</span>;</div><div class="line">                        }</div><div class="line">                        </div><div class="line">                        <span class="comment">// Project the point to the surface</span></div><div class="line">                        A3DVector2dData *face_solutions = <span class="keyword">nullptr</span>;</div><div class="line">                        A3DSurfProjectPoint( surface, &amp;pt, &amp;n_solutions, &amp;face_solutions, &amp;distances );</div><div class="line">                        <span class="keyword">auto</span> min_surf_distance = std::numeric_limits&lt;double&gt;::max();</div><div class="line">                        <span class="keywordflow">for</span>( <span class="keyword">auto</span> n_solution = 0u; n_solution &lt; n_solutions; ++n_solution ) {</div><div class="line">                            <span class="keywordflow">if</span>( distances[n_solution] &lt; min_surf_distance ) {</div><div class="line">                                min_surf_distance = distances[n_solution];</div><div class="line">                            }</div><div class="line">                        }</div><div class="line">                        A3DSurfProjectPoint( <span class="keyword">nullptr</span>, &amp;pt, &amp;n_solutions, &amp;face_solutions, &amp;distances );</div><div class="line"></div><div class="line">                        <span class="comment">// check resulting error against tolerance</span></div><div class="line">                        <span class="keyword">auto</span> <span class="keyword">const</span> surface_error = min_surf_distance;<span class="comment">// * brep_scale;</span></div><div class="line">                        <span class="keywordflow">if</span>( surface_error &gt; TOLERANCE ) {</div><div class="line">                            std::cerr &lt;&lt; <span class="stringliteral">&quot;FAILURE: [Distance to surface] &quot;</span> &lt;&lt; surface_error &lt;&lt; <span class="stringliteral">&quot; &gt; &quot;</span> &lt;&lt; TOLERANCE &lt;&lt; std::endl;</div><div class="line">                            failure_encountered = <span class="keyword">true</span>;</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><h1><a class="anchor" id="example_pmi_linked_items"></a>
How to access Markup/PMI Linked Items</h1>
<p>This snippet was extracted from <code>examples/pmi_linked_items/main.cpp</code>. </p><div class="fragment"><div class="line">    <span class="comment">// Use the function to get all markup objects</span></div><div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> all_markups = <a class="code" href="group__traversal.html#gaf65a30c9e905e2987bf29fd96296cc6c">ts3d::getLeafInstances</a>( loader.m_psModelFile, kA3DTypeMkpMarkup );</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;This file contains &quot;</span> &lt;&lt; all_markups.size() &lt;&lt; <span class="stringliteral">&quot; markups.&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// Loop over each markup object and examine if each has any linked items</span></div><div class="line">    <span class="keywordflow">for</span>( <span class="keyword">auto</span> <span class="keyword">const</span> this_markup : all_markups ) {</div><div class="line">        <a class="code" href="classts3d_1_1_instance.html">ts3d::Instance</a> markup_instance( this_markup );</div><div class="line">        <span class="keyword">auto</span> <span class="keyword">const</span> linked_items = <a class="code" href="group__traversal.html#gaf65a30c9e905e2987bf29fd96296cc6c">ts3d::getLeafInstances</a>( this_markup.back(), kA3DTypeMiscMarkupLinkedItem );</div><div class="line">        <span class="keywordflow">if</span>( ! linked_items.empty() ) {</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Mark-up: \&quot;&quot;</span> &lt;&lt; markup_instance.getName() &lt;&lt; <span class="stringliteral">&quot;\&quot; [&quot;</span> &lt;&lt; markup_instance.getType() &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="keywordflow">for</span>( <span class="keyword">auto</span> <span class="keyword">const</span> linked_item : linked_items ) {</div><div class="line">            <a class="code" href="structts3d_1_1_a3_d_misc_markup_linked_item_wrapper.html">ts3d::A3DMiscMarkupLinkedItemWrapper</a> d( linked_item.back() );</div><div class="line">            <span class="keywordflow">if</span>( kA3DTypeMiscReferenceOnTopology != <a class="code" href="group__access.html#gaef7e91c5c7c745e2e3953becbd2324fd">ts3d::getEntityType</a>( d-&gt;m_pReference ) ) {</div><div class="line">                <span class="comment">// This code is only handling linked items that reference topology</span></div><div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Unhandled reference type: &quot;</span> &lt;&lt; <a class="code" href="classts3d_1_1_instance.html">ts3d::Instance</a>( { d-&gt;m_pReference } ).getType() &lt;&lt; std::endl;</div><div class="line">                <span class="keywordflow">continue</span>;</div><div class="line">            }</div><div class="line">            </div><div class="line">            <span class="comment">// we&#39;ll use this data wrapper to obtain info about the topology reference</span></div><div class="line">            <a class="code" href="structts3d_1_1_a3_d_misc_reference_on_topology_wrapper.html">ts3d::A3DMiscReferenceOnTopologyWrapper</a> t( d-&gt;m_pReference );</div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> topo_brep_data_ptr = t-&gt;m_pBrepData;</div><div class="line">            <span class="keywordflow">if</span>( <span class="keyword">nullptr</span> == topo_brep_data_ptr ) {</div><div class="line">                <span class="keywordflow">continue</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// Do something unique for each possible type of referenced topology</span></div><div class="line">            <span class="keywordflow">switch</span>( t-&gt;m_eTopoItemType ) {</div><div class="line">                <span class="keywordflow">case</span> kA3DTypeTopoConnex:</div><div class="line">                    {</div><div class="line">                        <span class="keyword">auto</span> <span class="keyword">const</span> connex = <a class="code" href="group__traversal.html#gaf65a30c9e905e2987bf29fd96296cc6c">ts3d::getLeafInstances</a>( topo_brep_data_ptr, t-&gt;m_eTopoItemType )[t-&gt;m_puiAdditionalIndexes[0]];</div><div class="line">                        <a class="code" href="structts3d_1_1_a3_d_topo_connex_wrapper.html">ts3d::A3DTopoConnexWrapper</a> d( connex.back() );</div><div class="line">                        std::cout &lt;&lt; <span class="stringliteral">&quot;The linked connex contains &quot;</span> &lt;&lt; d-&gt;m_uiShellSize &lt;&lt; <span class="stringliteral">&quot; shell(s).&quot;</span> &lt;&lt; std::endl;</div><div class="line">                    }</div><div class="line">                    <span class="keywordflow">break</span>;</div><div class="line">                <span class="keywordflow">case</span> kA3DTypeTopoShell:</div><div class="line">                    {</div><div class="line">                        <span class="keyword">auto</span> <span class="keyword">const</span> shell = <a class="code" href="group__traversal.html#gaf65a30c9e905e2987bf29fd96296cc6c">ts3d::getLeafInstances</a>( topo_brep_data_ptr, t-&gt;m_eTopoItemType )[t-&gt;m_puiAdditionalIndexes[0]];</div><div class="line">                        <a class="code" href="structts3d_1_1_a3_d_topo_shell_wrapper.html">ts3d::A3DTopoShellWrapper</a> d( shell.back() );</div><div class="line">                        std::cout &lt;&lt; <span class="stringliteral">&quot;The linked shell contains &quot;</span> &lt;&lt; d-&gt;m_uiFaceSize &lt;&lt; <span class="stringliteral">&quot; face(s).&quot;</span> &lt;&lt; std::endl;</div><div class="line">                    }</div><div class="line">                    <span class="keywordflow">break</span>;</div><div class="line">                <span class="keywordflow">case</span> kA3DTypeTopoFace:</div><div class="line">                    {</div><div class="line">                        <span class="comment">// Print some info about the B-Rep</span></div><div class="line">                        <span class="keyword">auto</span> <span class="keyword">const</span> face = <a class="code" href="group__traversal.html#gaf65a30c9e905e2987bf29fd96296cc6c">ts3d::getLeafInstances</a>( topo_brep_data_ptr, t-&gt;m_eTopoItemType )[t-&gt;m_puiAdditionalIndexes[0]];</div><div class="line">                        <a class="code" href="structts3d_1_1_a3_d_topo_face_wrapper.html">ts3d::A3DTopoFaceWrapper</a> d( face.back() );</div><div class="line">                        std::cout &lt;&lt; <span class="stringliteral">&quot;The linked face has a surface type: &quot;</span> &lt;&lt; <a class="code" href="classts3d_1_1_instance.html">ts3d::Instance</a>( { d-&gt;m_pSurface } ).getType() &lt;&lt; <span class="stringliteral">&quot; and contains &quot;</span> &lt;&lt; d-&gt;m_uiLoopSize &lt;&lt; <span class="stringliteral">&quot; loop(s).&quot;</span> &lt;&lt; std::endl;</div><div class="line">                        </div><div class="line">                        <span class="comment">// Print some info about the associated tessellation</span></div><div class="line">                        <span class="keyword">auto</span> <span class="keyword">const</span> part_def = getPartDefinition( this_markup );</div><div class="line">                        <span class="keywordflow">if</span>( <span class="keyword">nullptr</span> != part_def ) {</div><div class="line">                            <span class="keyword">auto</span> <span class="keyword">const</span> ri_brep_models = <a class="code" href="group__traversal.html#gaf65a30c9e905e2987bf29fd96296cc6c">ts3d::getLeafInstances</a>( part_def, kA3DTypeRiBrepModel );</div><div class="line">                            <span class="keywordflow">if</span>( ! ri_brep_models.empty() ) {</div><div class="line">                                <span class="keyword">auto</span> <span class="keyword">const</span> ri_brep_model = ri_brep_models.back();</div><div class="line"></div><div class="line">                                <a class="code" href="classts3d_1_1_representation_item_instance.html">ts3d::RepresentationItemInstance</a> ri_instance( { ri_brep_model } );</div><div class="line">                                <span class="keywordflow">if</span>( <span class="keyword">auto</span> <span class="keyword">const</span> tess = std::dynamic_pointer_cast&lt;ts3d::Tess3DInstance&gt;( ri_instance.getTessellation() ) ) {</div><div class="line">                                    <span class="keyword">auto</span> <span class="keyword">const</span> index_mesh = tess-&gt;getIndexMeshForFace( t-&gt;m_puiAdditionalIndexes[0] );</div><div class="line">                                    std::cout &lt;&lt; <span class="stringliteral">&quot;The face&#39;s tessellation contains &quot;</span> &lt;&lt; index_mesh.vertices().size()/3u &lt;&lt; <span class="stringliteral">&quot; triangles.&quot;</span> &lt;&lt; std::endl;</div><div class="line">                                }</div><div class="line">                            }</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                    <span class="keywordflow">break</span>;</div><div class="line">                <span class="keywordflow">case</span> kA3DTypeTopoEdge:</div><div class="line">                <span class="keywordflow">case</span> kA3DTypeTopoCoEdge:</div><div class="line">                {</div><div class="line">                    <span class="comment">// Print some info about the B-Rep</span></div><div class="line">                    <span class="keyword">auto</span> <span class="keyword">const</span> faces = <a class="code" href="group__traversal.html#gaf65a30c9e905e2987bf29fd96296cc6c">ts3d::getLeafInstances</a>( topo_brep_data_ptr, kA3DTypeTopoFace );</div><div class="line">                    <span class="keyword">auto</span> <span class="keyword">const</span> face = faces[t-&gt;m_puiAdditionalIndexes[0]].back();</div><div class="line"></div><div class="line">                    <span class="keyword">auto</span> <span class="keyword">const</span> loops = <a class="code" href="group__traversal.html#gaf65a30c9e905e2987bf29fd96296cc6c">ts3d::getLeafInstances</a>( face, kA3DTypeTopoLoop );</div><div class="line">                    <span class="keyword">auto</span> <span class="keyword">const</span> loop = loops[t-&gt;m_puiAdditionalIndexes[1]].back();</div><div class="line"></div><div class="line">                    <span class="keyword">auto</span> <span class="keyword">const</span> coedges = <a class="code" href="group__traversal.html#gaf65a30c9e905e2987bf29fd96296cc6c">ts3d::getLeafInstances</a>( loop, kA3DTypeTopoCoEdge );</div><div class="line">                    <span class="keyword">auto</span> <span class="keyword">const</span> coedge = coedges[t-&gt;m_puiAdditionalIndexes[2]].back();</div><div class="line">                    <a class="code" href="structts3d_1_1_a3_d_topo_co_edge_wrapper.html">ts3d::A3DTopoCoEdgeWrapper</a> d( coedge );</div><div class="line">                    </div><div class="line">                    <span class="keyword">auto</span> <span class="keyword">const</span> curve = d-&gt;m_pUVCurve ? d-&gt;m_pUVCurve : <a class="code" href="structts3d_1_1_a3_d_topo_edge_wrapper.html">ts3d::A3DTopoEdgeWrapper</a>( d-&gt;m_pEdge )-&gt;m_p3dCurve;</div><div class="line">                    </div><div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;The linked coedge has a curve type: &quot;</span> &lt;&lt; <a class="code" href="classts3d_1_1_instance.html">ts3d::Instance</a>( { curve } ).getType() &lt;&lt; std::endl;</div><div class="line">                    </div><div class="line">                    <span class="comment">// Print some info about the associated tessellation</span></div><div class="line">                    <span class="keyword">auto</span> <span class="keyword">const</span> part_def = getPartDefinition( this_markup );</div><div class="line">                    <span class="keywordflow">if</span>( <span class="keyword">nullptr</span> != part_def ) {</div><div class="line">                        <span class="keyword">auto</span> <span class="keyword">const</span> ri_brep_models = <a class="code" href="group__traversal.html#gaf65a30c9e905e2987bf29fd96296cc6c">ts3d::getLeafInstances</a>( part_def, kA3DTypeRiBrepModel );</div><div class="line">                        <span class="keywordflow">if</span>( ! ri_brep_models.empty() ) {</div><div class="line">                            <span class="keyword">auto</span> <span class="keyword">const</span> ri_brep_model = ri_brep_models.back();</div><div class="line"></div><div class="line">                            <a class="code" href="classts3d_1_1_representation_item_instance.html">ts3d::RepresentationItemInstance</a> ri_instance( { ri_brep_model } );</div><div class="line">                            <span class="keywordflow">if</span>( <span class="keyword">auto</span> <span class="keyword">const</span> tess = std::dynamic_pointer_cast&lt;ts3d::Tess3DInstance&gt;( ri_instance.getTessellation() ) ) {</div><div class="line">                                <span class="keyword">auto</span> <span class="keyword">const</span> index_mesh = tess-&gt;getIndexMeshForFace( t-&gt;m_puiAdditionalIndexes[0] );</div><div class="line">                                <span class="keyword">auto</span> <span class="keyword">const</span> tess_loop = index_mesh.loops()[t-&gt;m_puiAdditionalIndexes[1]];</div><div class="line">                                <span class="keyword">auto</span> <span class="keyword">const</span> tess_edge = tess_loop._edges[t-&gt;m_puiAdditionalIndexes[2]];</div><div class="line">                                std::cout &lt;&lt; <span class="stringliteral">&quot;The edge&#39;s tessellation contains &quot;</span> &lt;&lt; tess_edge._vertices.size() &lt;&lt; <span class="stringliteral">&quot; points.&quot;</span> &lt;&lt; std::endl;</div><div class="line">                            }</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                }</div><div class="line">                    <span class="keywordflow">break</span>;</div><div class="line">                <span class="keywordflow">case</span> kA3DTypeTopoUniqueVertex:</div><div class="line">                <span class="keywordflow">case</span> kA3DTypeTopoMultipleVertex:</div><div class="line">                    {</div><div class="line">                        <span class="keyword">auto</span> <span class="keyword">const</span> faces = <a class="code" href="group__traversal.html#gaf65a30c9e905e2987bf29fd96296cc6c">ts3d::getLeafInstances</a>( topo_brep_data_ptr, kA3DTypeTopoFace );</div><div class="line">                        <span class="keyword">auto</span> <span class="keyword">const</span> face = faces[t-&gt;m_puiAdditionalIndexes[0]].back();</div><div class="line"></div><div class="line">                        <span class="keyword">auto</span> <span class="keyword">const</span> loops = <a class="code" href="group__traversal.html#gaf65a30c9e905e2987bf29fd96296cc6c">ts3d::getLeafInstances</a>( face, kA3DTypeTopoLoop );</div><div class="line">                        <span class="keyword">auto</span> <span class="keyword">const</span> loop = loops[t-&gt;m_puiAdditionalIndexes[1]].back();</div><div class="line"></div><div class="line">                        <span class="keyword">auto</span> <span class="keyword">const</span> edges = <a class="code" href="group__traversal.html#gaf65a30c9e905e2987bf29fd96296cc6c">ts3d::getLeafInstances</a>( loop, kA3DTypeTopoEdge );</div><div class="line">                        <span class="keyword">auto</span> <span class="keyword">const</span> edge = edges[t-&gt;m_puiAdditionalIndexes[2]].back();</div><div class="line"></div><div class="line">                        <span class="keyword">auto</span> <span class="keyword">const</span> vertices = <a class="code" href="group__traversal.html#gaf65a30c9e905e2987bf29fd96296cc6c">ts3d::getLeafInstances</a>( edge, kA3DTypeTopoVertex );</div><div class="line">                        <span class="keyword">auto</span> <span class="keyword">const</span> vertex = vertices[t-&gt;m_puiAdditionalIndexes[3]].back();</div><div class="line">                        <span class="keyword">auto</span> <span class="keyword">const</span> vertex_type = <a class="code" href="group__access.html#gaef7e91c5c7c745e2e3953becbd2324fd">ts3d::getEntityType</a>( vertex );</div><div class="line">                        <span class="keywordflow">if</span>( kA3DTypeTopoUniqueVertex == vertex_type ) {</div><div class="line">                            <a class="code" href="structts3d_1_1_a3_d_topo_unique_vertex_wrapper.html">ts3d::A3DTopoUniqueVertexWrapper</a> d( vertex );</div><div class="line">                            std::cout &lt;&lt; <span class="stringliteral">&quot;The linked vertex is at (&quot;</span> &lt;&lt; d-&gt;m_sPoint.m_dX &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; d-&gt;m_sPoint.m_dY &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; d-&gt;m_sPoint.m_dZ &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div><div class="line">                        } <span class="keywordflow">else</span> {</div><div class="line">                            <span class="comment">// kA3DTypeTopoMultipleVertex</span></div><div class="line">                            <a class="code" href="structts3d_1_1_a3_d_topo_multiple_vertex_wrapper.html">ts3d::A3DTopoMultipleVertexWrapper</a> d( vertex );</div><div class="line">                            std::cout &lt;&lt; <span class="stringliteral">&quot;The linked vertex has multiple positions at: &quot;</span> &lt;&lt; std::endl;</div><div class="line">                            <span class="keywordflow">for</span>( <span class="keyword">auto</span> idx = 0u; idx &lt; d-&gt;m_uiSize; ++idx ) {</div><div class="line">                                std::cout &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; d-&gt;m_pPts[idx].m_dX &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; d-&gt;m_pPts[idx].m_dY &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; d-&gt;m_pPts[idx].m_dZ &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div><div class="line">                            }</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                    <span class="keywordflow">break</span>;</div><div class="line">                <span class="keywordflow">default</span>:</div><div class="line">                    <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">    }</div></div><!-- fragment --><h1><a class="anchor" id="example_wire_body_curve_types"></a>
Print curve types that make up a wire body</h1>
<p>This snippet was extract from <code>examples/wire_body_curve_types/main.cpp</code>. </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> wire_edges = <a class="code" href="group__traversal.html#gaf65a30c9e905e2987bf29fd96296cc6c">ts3d::getLeafInstances</a>( loader.m_psModelFile, kA3DTypeTopoWireEdge);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;There are &quot;</span> &lt;&lt; wire_edges.size() &lt;&lt; <span class="stringliteral">&quot; single wire edges.&quot;</span> &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">for</span>( <span class="keyword">auto</span> <span class="keyword">const</span> we : wire_edges ) {</div><div class="line">        <a class="code" href="structts3d_1_1_a3_d_topo_wire_edge_wrapper.html">ts3d::A3DTopoWireEdgeWrapper</a> d( we.back() );</div><div class="line">        <a class="code" href="classts3d_1_1_instance.html">ts3d::Instance</a> i({ d-&gt;m_p3dCurve });</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Curve: &quot;</span> &lt;&lt; i.<a class="code" href="classts3d_1_1_instance.html#a5e346333fcbca9fef743ca5e9aba24fd">getType</a>();</div><div class="line">        <span class="keywordflow">if</span> (d-&gt;m_bHasTrimDomain) {</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot; [&quot;</span> &lt;&lt; d-&gt;m_sInterval.m_dMin &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; d-&gt;m_sInterval.m_dMax &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>;</div><div class="line">        }</div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">switch</span> (i.leafType()) {</div><div class="line">        <span class="keywordflow">case</span> kA3DTypeCrvPolyLine:</div><div class="line">        {</div><div class="line">            <a class="code" href="structts3d_1_1_a3_d_crv_poly_line_wrapper.html">ts3d::A3DCrvPolyLineWrapper</a> curve_data(i.leaf());</div><div class="line">            std::cout &lt;&lt; curve_data-&gt;m_uiSize &lt;&lt; <span class="stringliteral">&quot; pts&quot;</span> &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> kA3DTypeCrvCircle:</div><div class="line">        {</div><div class="line">            <a class="code" href="structts3d_1_1_a3_d_crv_circle_wrapper.html">ts3d::A3DCrvCircleWrapper</a> curve_data(i.leaf());</div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> &amp;o = curve_data-&gt;m_sTrsf.m_sOrigin;</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Center (&quot;</span> &lt;&lt; o.m_dX &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; o.m_dY &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; o.m_dZ &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Radius: &quot;</span> &lt;&lt; curve_data-&gt;m_dRadius &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> kA3DTypeCrvEllipse:</div><div class="line">        {</div><div class="line">            <a class="code" href="structts3d_1_1_a3_d_crv_ellipse_wrapper.html">ts3d::A3DCrvEllipseWrapper</a> curve_data(i.leaf());</div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> &amp;o = curve_data-&gt;m_sTrsf.m_sOrigin;</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Center (&quot;</span> &lt;&lt; o.m_dX &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; o.m_dY &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; o.m_dZ &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;X Radius: &quot;</span> &lt;&lt; curve_data-&gt;m_dXRadius &lt;&lt; std::endl;</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Y Radius: &quot;</span> &lt;&lt; curve_data-&gt;m_dYRadius &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> kA3DTypeCrvLine:</div><div class="line">        {</div><div class="line">            <a class="code" href="structts3d_1_1_a3_d_crv_line_wrapper.html">ts3d::A3DCrvLineWrapper</a> curve_data(i.leaf());</div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> &amp;o = curve_data-&gt;m_sTrsf.m_sOrigin;</div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> &amp;x = curve_data-&gt;m_sTrsf.m_sXVector;</div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> &amp;y = curve_data-&gt;m_sTrsf.m_sYVector;</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Origin (&quot;</span> &lt;&lt; o.m_dX &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; o.m_dY &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; o.m_dZ &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;X (&quot;</span> &lt;&lt; x.m_dX &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; x.m_dY &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; x.m_dZ &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Y (&quot;</span> &lt;&lt; y.m_dX &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; y.m_dY &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; y.m_dZ &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><h1><a class="anchor" id="example_obj"></a>
Write an OBJ file</h1>
<p>This snippet was extract from <code>examples/obj/main.cpp</code>. </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> ri_instances = <a class="code" href="group__traversal.html#gaf65a30c9e905e2987bf29fd96296cc6c">ts3d::getLeafInstances</a>( loader.m_psModelFile, kA3DTypeRiRepresentationItem );</div><div class="line">    <span class="keywordflow">for</span>( <span class="keyword">auto</span> ri_instance : ri_instances ) {</div><div class="line">        <a class="code" href="classts3d_1_1_representation_item_instance.html">ts3d::RepresentationItemInstance</a> <span class="keyword">const</span> ri( ri_instance );</div><div class="line">        <span class="keywordflow">if</span>( !ri.getNetShow() ) {</div><div class="line">            <span class="keywordflow">continue</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> <span class="keyword">const</span> tess3d = std::dynamic_pointer_cast&lt;<a class="code" href="classts3d_1_1_tess3_d_instance.html">ts3d::Tess3DInstance</a>&gt;( ri.getTessellation() );</div><div class="line">        <span class="keywordflow">if</span>( <span class="keyword">nullptr</span> == tess3d ) {</div><div class="line">            <span class="keywordflow">continue</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> <span class="keyword">const</span> name = ri.<a class="code" href="classts3d_1_1_instance.html#ad510254ee846664c4e9d39af70eef430">getName</a>();</div><div class="line">        obj_file &lt;&lt; <span class="stringliteral">&quot;o &quot;</span> &lt;&lt; name &lt;&lt; std::endl;</div><div class="line">        </div><div class="line">        <span class="keyword">auto</span> <span class="keyword">const</span> net_style = ri.getNetStyle();</div><div class="line">        <span class="keyword">auto</span> <span class="keyword">const</span> mtl = getMaterial( net_style );</div><div class="line">        <span class="keywordflow">if</span>( !mtl.empty() ) {</div><div class="line">            obj_file &lt;&lt; <span class="stringliteral">&quot;usemtl &quot;</span> &lt;&lt; mtl &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="keyword">auto</span> <span class="keyword">const</span> net_matrix = <a class="code" href="group__eigen__bridge.html#gabe127bcb8cffb23d2b7de2b694a6cd8a">ts3d::getNetMatrix</a>( ri );</div><div class="line">        <span class="keyword">auto</span> <span class="keyword">const</span> exchange_coords = tess3d-&gt;coords();</div><div class="line">        <span class="keyword">auto</span> <span class="keyword">const</span> n_coords = tess3d-&gt;coordsSize();</div><div class="line">        <span class="keywordflow">for</span>( <span class="keyword">auto</span> idx = 0u; idx &lt; n_coords; idx += 3 ) {</div><div class="line">            <span class="keyword">auto</span> v = net_matrix * <a class="code" href="group__eigen__bridge.html#ga91df0d88af94bf5ac5fcab5ea5580bd4">ts3d::VectorType</a>( exchange_coords[idx], exchange_coords[idx+1], exchange_coords[idx+2], 1. );</div><div class="line">            obj_file &lt;&lt; <span class="stringliteral">&quot;v &quot;</span> &lt;&lt; v(0) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; v(1) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; v(2) &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="keyword">auto</span> <span class="keyword">const</span> exchange_normals = tess3d-&gt;normals();</div><div class="line">        <span class="keyword">auto</span> <span class="keyword">const</span> n_normals = tess3d-&gt;normalsSize();</div><div class="line">        <span class="keywordflow">for</span>( <span class="keyword">auto</span> idx = 0u; idx &lt; n_normals; idx += 3 ) {</div><div class="line">            <span class="keyword">auto</span> n = net_matrix * <a class="code" href="group__eigen__bridge.html#ga91df0d88af94bf5ac5fcab5ea5580bd4">ts3d::VectorType</a>( exchange_normals[idx], exchange_normals[idx+1], exchange_normals[idx+2], 0. );</div><div class="line">            obj_file &lt;&lt; <span class="stringliteral">&quot;vn &quot;</span> &lt;&lt; n(0) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; n(1) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; n(2) &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="keywordflow">for</span>( <span class="keyword">auto</span> idx = 0u; idx &lt; tess3d-&gt;faceSize(); ++idx ) {</div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> face_mesh = tess3d-&gt;getIndexMeshForFace( idx );</div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> n_vertices = face_mesh.vertices().size();</div><div class="line">            <span class="keywordflow">for</span>(<span class="keyword">auto</span> idx = 0u; idx &lt; n_vertices; ++idx ) {</div><div class="line">                <span class="keywordflow">if</span>( 0 == idx % 3 ) {</div><div class="line">                    obj_file &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;f&quot;</span>;</div><div class="line">                }</div><div class="line">                </div><div class="line">                obj_file &lt;&lt; <span class="stringliteral">&quot; -&quot;</span> &lt;&lt; (n_coords - face_mesh.vertices()[idx])/3 &lt;&lt; <span class="stringliteral">&quot;//-&quot;</span> &lt;&lt; (n_normals - face_mesh.normals()[idx])/3;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        obj_file &lt;&lt; std::endl;</div><div class="line">    }</div></div><!-- fragment --><h1><a class="anchor" id="example_print_structure"></a>
Print the product structure</h1>
<p>These snippers were extracted from <code>examples/print_structure/main.cpp</code> </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> printNameAndRecurse( A3DEntity *owner, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level ) {</div><div class="line">    <span class="keywordflow">for</span>( <span class="keyword">auto</span> idx = 0u; idx &lt; level; ++idx ) {</div><div class="line">        std::cout &lt;&lt; <span class="charliteral">&#39;\t&#39;</span>;</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; <a class="code" href="classts3d_1_1_instance.html">ts3d::Instance</a>( {owner} ).getName() &lt;&lt; std::endl;</div><div class="line">    level++;</div><div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> children = <a class="code" href="group__traversal.html#gaa042faeb962f3ab7c180772a98776d10">ts3d::getChildren</a>( owner, kA3DTypeAsmProductOccurrence );</div><div class="line">    <span class="keywordflow">for</span>( <span class="keyword">auto</span> <span class="keyword">const</span> child : children ) {</div><div class="line">        printNameAndRecurse( child, level );</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>This function is used in the body of main as follows. </p><div class="fragment"><div class="line">    loader.Import( i );</div><div class="line">    <span class="keywordflow">if</span>( <span class="keyword">nullptr</span> == loader.m_psModelFile ) {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;The specified file could not be loaded.&quot;</span> &lt;&lt; std::endl;</div><div class="line">        <span class="keywordflow">return</span> -1;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> level = 0u;</div><div class="line">    printNameAndRecurse( loader.m_psModelFile, level );</div></div><!-- fragment --></div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
